/*!
 * Bootstrap v5.1.3 (https://getbootstrap.com/)
 * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 */ !(function (e, t) {
  "object" == typeof exports && "undefined" != typeof module
    ? (module.exports = t())
    : "function" == typeof define && define.amd
    ? define(t)
    : ((e =
        "undefined" != typeof globalThis ? globalThis : e || self).bootstrap =
        t());
})(this, function () {
  "use strict";
  let e = "transitionend",
    t = (e) =>
      null == e
        ? `${e}`
        : {}.toString
            .call(e)
            .match(/\s([a-z]+)/i)[1]
            .toLowerCase(),
    n = (e) => {
      let t = e.getAttribute("data-bs-target");
      if (!t || "#" === t) {
        let n = e.getAttribute("href");
        if (!n || (!n.includes("#") && !n.startsWith("."))) return null;
        n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`),
          (t = n && "#" !== n ? n.trim() : null);
      }
      return t;
    },
    i = (e) => {
      let t = n(e);
      return t ? document.querySelector(t) : null;
    },
    s = (e) => {
      if (!e) return 0;
      let { transitionDuration: t, transitionDelay: n } =
          window.getComputedStyle(e),
        i = Number.parseFloat(t),
        s = Number.parseFloat(n);
      return i || s
        ? ((t = t.split(",")[0]),
          (n = n.split(",")[0]),
          (Number.parseFloat(t) + Number.parseFloat(n)) * 1e3)
        : 0;
    },
    r = (t) => {
      t.dispatchEvent(new Event(e));
    },
    a = (e) =>
      !!e &&
      "object" == typeof e &&
      (void 0 !== e.jquery && (e = e[0]), void 0 !== e.nodeType),
    o = (e) =>
      a(e)
        ? e.jquery
          ? e[0]
          : e
        : "string" == typeof e && e.length > 0
        ? document.querySelector(e)
        : null,
    l = (e, n, i) => {
      Object.keys(i).forEach((s) => {
        let r = i[s],
          o = n[s],
          l = o && a(o) ? "element" : t(o);
        if (!RegExp(r).test(l))
          throw TypeError(
            `${e.toUpperCase()}: Option "${s}" provided type "${l}" but expected type "${r}".`
          );
      });
    },
    c = (e) =>
      !!a(e) &&
      0 !== e.getClientRects().length &&
      "visible" === getComputedStyle(e).getPropertyValue("visibility"),
    u = (e) => {
      e.offsetHeight;
    },
    d = () => {
      let { jQuery: e } = window;
      return e && !document.body.hasAttribute("data-bs-no-jquery") ? e : null;
    },
    p = [],
    h = (e) => {
      "loading" === document.readyState
        ? (p.length ||
            document.addEventListener("DOMContentLoaded", () => {
              p.forEach((e) => e());
            }),
          p.push(e))
        : e();
    },
    f = () => "rtl" === document.documentElement.dir,
    g = (e) => {
      h(() => {
        let t = d();
        if (t) {
          let n = e.NAME,
            i = t.fn[n];
          (t.fn[n] = e.jQueryInterface),
            (t.fn[n].Constructor = e),
            (t.fn[n].noConflict = () => ((t.fn[n] = i), e.jQueryInterface));
        }
      });
    },
    m = (e) => {
      "function" == typeof e && e();
    },
    v = (t, n, i = !0) => {
      if (!i) {
        m(t);
        return;
      }
      let a = s(n) + 5,
        o = !1,
        l = ({ target: i }) => {
          i === n && ((o = !0), n.removeEventListener(e, l), m(t));
        };
      n.addEventListener(e, l),
        setTimeout(() => {
          o || r(n);
        }, a);
    },
    b = (e, t, n, i) => {
      let s = e.indexOf(t);
      if (-1 === s) return e[!n && i ? e.length - 1 : 0];
      let r = e.length;
      return (
        (s += n ? 1 : -1),
        i && (s = (s + r) % r),
        e[Math.max(0, Math.min(s, r - 1))]
      );
    },
    y = /[^.]*(?=\..*)\.|.*/,
    E = /\..*/,
    $ = {},
    w = 1,
    I = { mouseenter: "mouseover", mouseleave: "mouseout" },
    A = /^(mouseenter|mouseleave)/i,
    O = new Set([
      "click",
      "dblclick",
      "mouseup",
      "mousedown",
      "contextmenu",
      "mousewheel",
      "DOMMouseScroll",
      "mouseover",
      "mouseout",
      "mousemove",
      "selectstart",
      "selectend",
      "keydown",
      "keypress",
      "keyup",
      "orientationchange",
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel",
      "pointerdown",
      "pointermove",
      "pointerup",
      "pointerleave",
      "pointercancel",
      "gesturestart",
      "gesturechange",
      "gestureend",
      "focus",
      "blur",
      "change",
      "reset",
      "select",
      "submit",
      "focusin",
      "focusout",
      "load",
      "unload",
      "beforeunload",
      "resize",
      "move",
      "DOMContentLoaded",
      "readystatechange",
      "error",
      "abort",
      "scroll",
    ]);
  function S(e, t) {
    return (t && `${t}::${w++}`) || e.uidEvent || w++;
  }
  function D(e) {
    return I[(e = e.replace(E, ""))] || e;
  }
  let k = {
      on(e, t, n, i) {
        !(function e(t, n, i, s, r) {
          var a, o, l, c, u;
          if ("string" != typeof n || !t) return;
          if ((i || ((i = s), (s = null)), A.test(n))) {
            let d = (e) =>
              function (t) {
                if (
                  !t.relatedTarget ||
                  (t.relatedTarget !== t.delegateTarget &&
                    !t.delegateTarget.contains(t.relatedTarget))
                )
                  return e.call(this, t);
              };
            s ? (s = d(s)) : (i = d(i));
          }
          let [p, h, f] = (function e(t, n, i) {
              let s = "string" == typeof n,
                r = D(t),
                a = O.has(r);
              return a || (r = t), [s, s ? i : n, r];
            })(n, i, s),
            g = (function e(t) {
              let n = S(t);
              return (t.uidEvent = n), ($[n] = $[n] || {}), $[n];
            })(t),
            m = g[f] || (g[f] = {}),
            v = (function e(t, n, i = null) {
              let s = Object.keys(t);
              for (let r = 0, a = s.length; r < a; r++) {
                let o = t[s[r]];
                if (o.originalHandler === n && o.delegationSelector === i)
                  return o;
              }
              return null;
            })(m, h, p ? i : null);
          if (v) {
            v.oneOff = v.oneOff && r;
            return;
          }
          let b = S(h, n.replace(y, "")),
            E = p
              ? ((a = t),
                (o = i),
                (l = s),
                function e(t) {
                  let n = a.querySelectorAll(o);
                  for (let { target: i } = t; i && i !== this; i = i.parentNode)
                    for (let s = n.length; s--; )
                      if (n[s] === i)
                        return (
                          (t.delegateTarget = i),
                          e.oneOff && k.off(a, t.type, o, l),
                          l.apply(i, [t])
                        );
                  return null;
                })
              : ((c = t),
                (u = i),
                function e(t) {
                  return (
                    (t.delegateTarget = c),
                    e.oneOff && k.off(c, t.type, u),
                    u.apply(c, [t])
                  );
                });
          (E.delegationSelector = p ? i : null),
            (E.originalHandler = h),
            (E.oneOff = r),
            (E.uidEvent = b),
            (m[b] = E),
            t.addEventListener(f, E, p);
        })(e, t, n, i, !1);
      },
      trigger(e, t, n) {
        if ("string" != typeof t || !e) return null;
        let i = d(),
          s = D(t),
          r = O.has(s),
          a,
          o = !0,
          l = !0,
          c = !1,
          u = null;
        return (
          t !== s &&
            i &&
            ((a = i.Event(t, n)),
            i(e).trigger(a),
            (o = !a.isPropagationStopped()),
            (l = !a.isImmediatePropagationStopped()),
            (c = a.isDefaultPrevented())),
          r
            ? (u = document.createEvent("HTMLEvents")).initEvent(s, o, !0)
            : (u = new CustomEvent(t, { bubbles: o, cancelable: !0 })),
          void 0 !== n &&
            Object.keys(n).forEach((e) => {
              Object.defineProperty(u, e, { get: () => n[e] });
            }),
          c && u.preventDefault(),
          l && e.dispatchEvent(u),
          u.defaultPrevented && void 0 !== a && a.preventDefault(),
          u
        );
      },
    },
    x = new Map(),
    L = {
      set(e, t, n) {
        x.has(e) || x.set(e, new Map());
        let i = x.get(e);
        if (!i.has(t) && 0 !== i.size) {
          console.error(
            `Bootstrap doesn't allow more than one instance per element. Bound instance: ${
              Array.from(i.keys())[0]
            }.`
          );
          return;
        }
        i.set(t, n);
      },
      get: (e, t) => (x.has(e) && x.get(e).get(t)) || null,
    };
  class T {
    constructor(e) {
      if (!(e = o(e))) return;
      (this._element = e),
        L.set(this._element, this.constructor.DATA_KEY, this);
    }
    _queueCallback(e, t, n = !0) {
      v(e, t, n);
    }
    static getInstance(e) {
      return L.get(o(e), this.DATA_KEY);
    }
    static getOrCreateInstance(e, t = {}) {
      return (
        this.getInstance(e) || new this(e, "object" == typeof t ? t : null)
      );
    }
    static get VERSION() {
      return "5.1.3";
    }
    static get NAME() {
      throw Error(
        'You have to implement the static method "NAME", for each component!'
      );
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
  }
  let _ = (e, t = "hide") => {
    let n = `click.dismiss${e.EVENT_KEY}`,
      i = e.NAME;
    k.on(document, n, `[data-bs-dismiss="${i}"]`);
  };
  class C extends T {
    static get NAME() {
      return "alert";
    }
    static jQueryInterface(e) {
      return this.each(function () {
        let t = C.getOrCreateInstance(this);
        if ("string" == typeof e) {
          if (void 0 === t[e] || e.startsWith("_") || "constructor" === e)
            throw TypeError(`No method named "${e}"`);
          t[e](this);
        }
      });
    }
  }
  _(C, "close"), g(C);
  let N = "click.bs.button.data-api";
  class M extends T {
    static get NAME() {
      return "button";
    }
    static jQueryInterface(e) {
      return this.each(function () {
        let t = M.getOrCreateInstance(this);
        "toggle" === e && t[e]();
      });
    }
  }
  k.on(document, N, '[data-bs-toggle="button"]', (e) => {}), g(M);
  let P = {
      getDataAttributes(e) {
        if (!e) return {};
        let t = {};
        return (
          Object.keys(e.dataset)
            .filter((e) => e.startsWith("bs"))
            .forEach((n) => {
              var i;
              let s = n.replace(/^bs/, "");
              t[(s = s.charAt(0).toLowerCase() + s.slice(1, s.length))] =
                "true" === (i = e.dataset[n]) ||
                ("false" !== i &&
                  (i === Number(i).toString()
                    ? Number(i)
                    : "" === i || "null" === i
                    ? null
                    : i));
            }),
          t
        );
      },
    },
    j = {
      find: (e, t = document.documentElement) =>
        [].concat(...Element.prototype.querySelectorAll.call(t, e)),
      findOne: (e, t = document.documentElement) =>
        Element.prototype.querySelector.call(t, e),
    },
    H = "carousel",
    X = ".bs.carousel",
    z = ".data-api",
    U = {
      interval: 5e3,
      keyboard: !0,
      slide: !1,
      pause: "hover",
      wrap: !0,
      touch: !0,
    },
    q = {
      interval: "(number|boolean)",
      keyboard: "boolean",
      slide: "(boolean|string)",
      pause: "(string|boolean)",
      wrap: "boolean",
      touch: "boolean",
    },
    F = "next",
    W = "prev",
    K = "left",
    R = "right",
    V = `slide${X}`,
    B = `slid${X}`,
    Y = `keydown${X}`,
    Q = `mouseenter${X}`,
    G = `mouseleave${X}`,
    J = `touchstart${X}`,
    Z = `touchmove${X}`,
    ee = `touchend${X}`,
    et = `pointerdown${X}`,
    en = `pointerup${X}`,
    ei = `dragstart${X}`,
    es = `load${X}${z}`,
    er = `click${X}${z}`,
    ea = "active",
    eo = ".active.carousel-item";
  class el extends T {
    constructor(e, t) {
      super(e),
        (this._items = null),
        (this._interval = null),
        (this._activeElement = null),
        (this._isPaused = !1),
        (this._isSliding = !1),
        (this.touchTimeout = null),
        (this.touchStartX = 0),
        (this.touchDeltaX = 0),
        (this._config = this._getConfig(t)),
        (this._indicatorsElement = j.findOne(
          ".carousel-indicators",
          this._element
        )),
        (this._touchSupported =
          "ontouchstart" in document.documentElement ||
          navigator.maxTouchPoints > 0),
        (this._pointerEvent = Boolean(window.PointerEvent)),
        this._addEventListeners();
    }
    static get Default() {
      return U;
    }
    static get NAME() {
      return H;
    }
    next() {
      this._slide(F);
    }
    prev() {
        this._slide(W);
    }
    nextWhenVisible() {
      !document.hidden && c(this._element) && this.next();
    }
    pause(e) {
      e || (this._isPaused = !0),
        j.findOne(".carousel-item-next, .carousel-item-prev", this._element) &&
          (r(this._element), this.cycle(!0)),
        clearInterval(this._interval),
        (this._interval = null);
    }
    cycle(e) {
      e || (this._isPaused = !1),
        this._interval &&
          (clearInterval(this._interval), (this._interval = null)),
        this._config &&
          this._config.interval &&
          !this._isPaused &&
          (this._updateInterval(),
          (this._interval = setInterval(
            (document.visibilityState ? this.nextWhenVisible : this.next).bind(
              this
            ),
            this._config.interval
          )));
    }
    _getConfig(e) {
      return (
        l(
          H,
          (e = {
            ...U,
            ...P.getDataAttributes(this._element),
            ...("object" == typeof e ? e : {}),
          }),
          q
        ),
        e
      );
    }
    _handleSwipe() {
      let e = Math.abs(this.touchDeltaX);
      if (e <= 40) return;
      let t = e / this.touchDeltaX;
      (this.touchDeltaX = 0), t && this._slide(t > 0 ? R : K);
    }
    _addEventListeners() {
      this._config.keyboard && k.on(this._element, Y, (e) => this._keydown(e)),
        "hover" === this._config.pause &&
          (k.on(this._element, Q, (e) => this.pause(e)),
          k.on(this._element, G, (e) => this.cycle(e))),
        this._config.touch &&
          this._touchSupported &&
          this._addTouchEventListeners();
    }
    _addTouchEventListeners() {
      let e = (e) =>
          this._pointerEvent &&
          ("pen" === e.pointerType || "touch" === e.pointerType),
        t = (t) => {
          e(t)
            ? (this.touchStartX = t.clientX)
            : this._pointerEvent || (this.touchStartX = t.touches[0].clientX);
        },
        n = (e) => {
          this.touchDeltaX =
            e.touches && e.touches.length > 1
              ? 0
              : e.touches[0].clientX - this.touchStartX;
        },
        i = (t) => {
          e(t) && (this.touchDeltaX = t.clientX - this.touchStartX),
            this._handleSwipe(),
            "hover" === this._config.pause &&
              (this.pause(),
              this.touchTimeout && clearTimeout(this.touchTimeout),
              (this.touchTimeout = setTimeout(
                (e) => this.cycle(e),
                500 + this._config.interval
              )));
        };
      j.find(".carousel-item img", this._element).forEach((e) => {
        k.on(e, ei, (e) => e.preventDefault());
      }),
        this._pointerEvent
          ? (k.on(this._element, et, (e) => t(e)),
            k.on(this._element, en, (e) => i(e)),
            this._element.classList.add("pointer-event"))
          : (k.on(this._element, J, (e) => t(e)),
            k.on(this._element, Z, (e) => n(e)),
            k.on(this._element, ee, (e) => i(e)));
    }
    _getItemIndex(e) {
      return (
        (this._items =
          e && e.parentNode ? j.find(".carousel-item", e.parentNode) : []),
        this._items.indexOf(e)
      );
    }
    _getItemByOrder(e, t) {
      return b(this._items, t, e === F, this._config.wrap);
    }
    _triggerSlideEvent(e, t) {
      let n = this._getItemIndex(e),
        i = this._getItemIndex(j.findOne(eo, this._element));
      return k.trigger(this._element, V, {
        relatedTarget: e,
        direction: t,
        from: i,
        to: n,
      });
    }
    _setActiveIndicatorElement(e) {
      if (this._indicatorsElement) {
        let t = j.findOne(".active", this._indicatorsElement);
        t.classList.remove(ea), t.removeAttribute("aria-current");
        let n = j.find("[data-bs-target]", this._indicatorsElement);
        for (let i = 0; i < n.length; i++)
          if (
            Number.parseInt(n[i].getAttribute("data-bs-slide-to"), 10) ===
            this._getItemIndex(e)
          ) {
            n[i].classList.add(ea), n[i].setAttribute("aria-current", "true");
            break;
          }
      }
    }
    _updateInterval() {
      let e = this._activeElement || j.findOne(eo, this._element);
      if (!e) return;
      let t = Number.parseInt(e.getAttribute("data-bs-interval"), 10);
      t
        ? ((this._config.defaultInterval =
            this._config.defaultInterval || this._config.interval),
          (this._config.interval = t))
        : (this._config.interval =
            this._config.defaultInterval || this._config.interval);
    }
    _slide(e, t) {
      let n = this._directionToOrder(e),
        i = j.findOne(eo, this._element),
        s = this._getItemIndex(i),
        r = t || this._getItemByOrder(n, i),
        a = this._getItemIndex(r),
        o = Boolean(this._interval),
        l = n === F,
        c = l ? "carousel-item-start" : "carousel-item-end",
        d = l ? "carousel-item-next" : "carousel-item-prev",
        p = this._orderToDirection(n);
      if (r && r.classList.contains(ea)) {
        this._isSliding = !1;
        return;
      }
      if (this._isSliding) return;
      let h = this._triggerSlideEvent(r, p);
      if (h.defaultPrevented || !i || !r) return;
      (this._isSliding = !0),
        o && this.pause(),
        this._setActiveIndicatorElement(r),
        (this._activeElement = r);
      let f = () => {
        k.trigger(this._element, B, {
          relatedTarget: r,
          direction: p,
          from: s,
          to: a,
        });
      };
      if (this._element.classList.contains("slide")) {
        r.classList.add(d), u(r), i.classList.add(c), r.classList.add(c);
        let g = () => {
          r.classList.remove(c, d),
            r.classList.add(ea),
            i.classList.remove(ea, d, c),
            (this._isSliding = !1),
            setTimeout(f, 0);
        };
        this._queueCallback(g, i, !0);
      } else i.classList.remove(ea), r.classList.add(ea), (this._isSliding = !1), f();
      o && this.cycle();
    }
    _directionToOrder(e) {
      return [R, K].includes(e)
        ? f()
          ? e === K
            ? W
            : F
          : e === K
          ? F
          : W
        : e;
    }
    _orderToDirection(e) {
      return [F, W].includes(e)
        ? f()
          ? e === W
            ? K
            : R
          : e === W
          ? R
          : K
        : e;
    }
    static carouselInterface(e, t) {
      let n = el.getOrCreateInstance(e, t),
        { _config: i } = n;
      "object" == typeof t && (i = { ...i, ...t });
      let s = "string" == typeof t ? t : i.slide;
      if ("number" == typeof t) n.to(t);
      else if ("string" == typeof s) {
        if (void 0 === n[s]) throw TypeError(`No method named "${s}"`);
        n[s]();
      } else i.interval && i.ride && (n.pause(), n.cycle());
    }
    static jQueryInterface(e) {}
    static dataApiClickHandler(e) {
      let t = i(this);
      if (!t || !t.classList.contains("carousel")) return;
      let n = { ...P.getDataAttributes(t), ...P.getDataAttributes(this) },
        s = this.getAttribute("data-bs-slide-to");
      s && (n.interval = !1),
        el.carouselInterface(t, n),
        s && el.getInstance(t).to(s),
        e.preventDefault();
    }
  }
  k.on(
    document,
    er,
    "[data-bs-slide], [data-bs-slide-to]",
    el.dataApiClickHandler
  ),
    k.on(window, es, () => {
      let e = j.find('[data-bs-ride="carousel"]');
      for (let t = 0, n = e.length; t < n; t++)
        el.carouselInterface(e[t], el.getInstance(e[t]));
    }),
    g(el);
  let ec = "click.bs.collapse.data-api";
  class eu extends T {}
  k.on(document, ec, '[data-bs-toggle="collapse"]', function (e) {}), g(eu);
  var ed = "bottom",
    ep = "right",
    eh = "left",
    ef = "auto",
    eg = ["top", ed, ep, eh],
    em = "start",
    ev = "popper",
    eb =
      (1,
      [].concat(eg, [ef]).reduce(function (e, t) {
        return e.concat([t, t + "-" + em, t + "-end"]);
      }, []));
  let e8 = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: function e(t) {
      var n = t.state;
      Object.keys(n.elements).forEach(function (e) {
        var t = n.styles[e] || {},
          i = n.attributes[e] || {},
          s = n.elements[e];
        isHTMLElement(s) &&
          getNodeName(s) &&
          (Object.assign(s.style, t),
          Object.keys(i).forEach(function (e) {
            var t = i[e];
            !1 === t
              ? s.removeAttribute(e)
              : s.setAttribute(e, !0 === t ? "" : t);
          }));
      });
    },
    effect: function e(t) {
      var n = t.state,
        i = {
          popper: {
            position: n.options.strategy,
            left: "0",
            top: "0",
            margin: "0",
          },
          arrow: { position: "absolute" },
          reference: {},
        };
      return (
        Object.assign(n.elements.popper.style, i.popper),
        (n.styles = i),
        n.elements.arrow && Object.assign(n.elements.arrow.style, i.arrow),
        function () {
          Object.keys(n.elements).forEach(function (e) {
            var t = n.elements[e],
              s = n.attributes[e] || {},
              r = Object.keys(
                n.styles.hasOwnProperty(e) ? n.styles[e] : i[e]
              ).reduce(function (e, t) {
                return (e[t] = ""), e;
              }, {});
            isHTMLElement(t) &&
              getNodeName(t) &&
              (Object.assign(t.style, r),
              Object.keys(s).forEach(function (e) {
                t.removeAttribute(e);
              }));
          });
        }
      );
    },
    requires: ["computeStyles"],
  };
  var ey = Math.max,
    eE = Math.min;
  let e$ = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: function e(t) {
      var n = t.state,
        i = t.options,
        s = i.gpuAcceleration,
        r = i.adaptive,
        a = i.roundOffsets,
        o = void 0 === a || a,
        l = {
          placement: getBasePlacement(n.placement),
          variation: getVariation(n.placement),
          popper: n.elements.popper,
          popperRect: n.rects.popper,
          gpuAcceleration: void 0 === s || s,
        };
      null != n.modifiersData.popperOffsets &&
        (n.styles.popper = Object.assign(
          {},
          n.styles.popper,
          mapToStyles(
            Object.assign({}, l, {
              offsets: n.modifiersData.popperOffsets,
              position: n.options.strategy,
              adaptive: void 0 === r || r,
              roundOffsets: o,
            })
          )
        )),
        null != n.modifiersData.arrow &&
          (n.styles.arrow = Object.assign(
            {},
            n.styles.arrow,
            mapToStyles(
              Object.assign({}, l, {
                offsets: n.modifiersData.arrow,
                position: "absolute",
                adaptive: !1,
                roundOffsets: o,
              })
            )
          )),
        (n.attributes.popper = Object.assign({}, n.attributes.popper, {
          "data-popper-placement": n.placement,
        }));
    },
    data: {},
  };
  var e9 = { passive: !0 };
  let ew = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function e() {},
    effect: function e(t) {
      var n = t.state,
        i = t.instance,
        s = t.options,
        r = s.scroll,
        a = void 0 === r || r,
        o = s.resize,
        l = void 0 === o || o,
        c = getWindow(n.elements.popper),
        u = [].concat(n.scrollParents.reference, n.scrollParents.popper);
      return (
        a &&
          u.forEach(function (e) {
            e.addEventListener("scroll", i.update, e9);
          }),
        l && c.addEventListener("resize", i.update, e9),
        function () {
          a &&
            u.forEach(function (e) {
              e.removeEventListener("scroll", i.update, e9);
            }),
            l && c.removeEventListener("resize", i.update, e9);
        }
      );
    },
    data: {},
  };
  function eI(e, t) {
    void 0 === t && (t = {});
    var n = t,
      i = n.placement,
      s = void 0 === i ? e.placement : i,
      r = n.boundary,
      a = n.rootBoundary,
      o = n.elementContext,
      l = void 0 === o ? ev : o,
      c = n.altBoundary,
      u = n.padding,
      d = void 0 === u ? 0 : u,
      p = mergePaddingObject("number" != typeof d ? d : expandToHashMap(d, eg)),
      h = e.rects.popper,
      f = e.elements[void 0 !== c && c ? (l === ev ? "reference" : ev) : l],
      g = getClippingRect(
        isElement(f)
          ? f
          : f.contextElement || getDocumentElement(e.elements.popper),
        void 0 === r ? "clippingParents" : r,
        void 0 === a ? "viewport" : a
      ),
      m = getBoundingClientRect(e.elements.reference),
      v = computeOffsets({
        reference: m,
        element: h,
        strategy: "absolute",
        placement: s,
      }),
      b = rectToClientRect(Object.assign({}, h, v)),
      y = l === ev ? b : m,
      E = {
        top: g.top - y.top + p.top,
        bottom: y.bottom - g.bottom + p.bottom,
        left: g.left - y.left + p.left,
        right: y.right - g.right + p.right,
      },
      $ = e.modifiersData.offset;
    if (l === ev && $) {
      var w = $[s];
      Object.keys(E).forEach(function (e) {
        var t = [ep, ed].indexOf(e) >= 0 ? 1 : -1,
          n = ["top", ed].indexOf(e) >= 0 ? "y" : "x";
        E[e] += w[n] * t;
      });
    }
    return E;
  }
  let eA = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: function e(t) {
      var n = t.state,
        i = t.name;
      n.modifiersData[i] = computeOffsets({
        reference: n.rects.reference,
        element: n.rects.popper,
        strategy: "absolute",
        placement: n.placement,
      });
    },
    data: {},
  };
  function eO(e) {
    void 0 === e && (e = {});
    var t = e;
    return t.defaultModifiers, t.defaultOptions, function e(t, n, i) {};
  }
  1;
  let eS = ".bs.dropdown",
    eD = ".data-api";
  RegExp("ArrowUp|ArrowDown|Escape");
  let ek = `click${eS}${eD}`,
    ex = `keydown${eS}${eD}`,
    eL = `keyup${eS}${eD}`,
    eT = '[data-bs-toggle="dropdown"]';
  f(), f(), f(), f(), f(), f();
  class e_ extends T {
    static clearMenus(e) {}
  }
  k.on(document, ex, eT, e_.dataApiKeydownHandler),
    k.on(document, ex, ".dropdown-menu", e_.dataApiKeydownHandler),
    k.on(document, ek, e_.clearMenus),
    k.on(document, eL, e_.clearMenus),
    k.on(document, ek, eT, function (e) {
      e.preventDefault(), e_.getOrCreateInstance(this).toggle();
    }),
    g(e_);
  class eC {}
  class eN {}
  class eM {}
  let eP = "click.bs.modal.data-api";
  class ej extends T {
    static get NAME() {
      return "modal";
    }
  }
  k.on(document, eP, '[data-bs-toggle="modal"]', function (e) {}), _(ej), g(ej);
  let eH = ".bs.offcanvas",
    eX = ".data-api",
    ez = `load${eH}${eX}`,
    eU = { backdrop: !0, keyboard: !0, scroll: !1 },
    eq = ".offcanvas.show",
    eF = `hidden${eH}`,
    eW = `click${eH}${eX}`;
  class eK extends T {
    constructor(e, t) {
      super(e),
        (this._config = this._getConfig(t)),
        (this._isShown = !1),
        (this._backdrop = this._initializeBackDrop()),
        (this._focustrap = this._initializeFocusTrap()),
        this._addEventListeners();
    }
    static get NAME() {
      return "offcanvas";
    }
    static get Default() {
      return eU;
    }
  }
  k.on(document, eW, '[data-bs-toggle="offcanvas"]', function (e) {
    let t = i(this);
    if (
      (["A", "AREA"].includes(this.tagName) && e.preventDefault(),
      isDisabled(this))
    )
      return;
    k.one(t, eF, () => {
      c(this) && this.focus();
    });
    let n = j.findOne(eq);
    n && n !== t && eK.getInstance(n).hide();
    let s = eK.getOrCreateInstance(t);
    s.toggle(this);
  }),
    k.on(window, ez, () =>
      j.find(eq).forEach((e) => eK.getOrCreateInstance(e).show())
    ),
    _(eK),
    g(eK);
  let eR = ".bs.tooltip",
    eV = {
      animation: "boolean",
      template: "string",
      title: "(string|element|function)",
      trigger: "string",
      delay: "(number|object)",
      html: "boolean",
      selector: "(string|boolean)",
      placement: "(string|function)",
      offset: "(array|string|function)",
      container: "(string|element|boolean)",
      fallbackPlacements: "array",
      boundary: "(string|element)",
      customClass: "(string|function)",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      allowList: "object",
      popperConfig: "(null|object|function)",
    };
  f(), f();
  let eB = {
      animation: !0,
      template:
        '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
      trigger: "hover focus",
      title: "",
      delay: 0,
      html: !1,
      selector: !1,
      placement: "top",
      offset: [0, 0],
      container: !1,
      fallbackPlacements: ["top", "right", "bottom", "left"],
      boundary: "clippingParents",
      customClass: "",
      sanitize: !0,
      sanitizeFn: null,
      allowList: {
        "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: [],
      },
      popperConfig: null,
    },
    eY = {
      HIDE: `hide${eR}`,
      HIDDEN: `hidden${eR}`,
      SHOW: `show${eR}`,
      SHOWN: `shown${eR}`,
      INSERTED: `inserted${eR}`,
      CLICK: `click${eR}`,
      FOCUSIN: `focusin${eR}`,
      FOCUSOUT: `focusout${eR}`,
      MOUSEENTER: `mouseenter${eR}`,
      MOUSELEAVE: `mouseleave${eR}`,
    };
  class eQ extends T {
    static get Default() {
      return eB;
    }
    static get NAME() {
      return "tooltip";
    }
    static get Event() {
      return eY;
    }
    static get DefaultType() {
      return eV;
    }
  }
  g(eQ);
  let e3 = ".bs.popover",
    e1 = {
      ...eQ.Default,
      placement: "right",
      offset: [0, 8],
      trigger: "click",
      content: "",
      template:
        '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    },
    e2 = { ...eQ.DefaultType, content: "(string|element|function)" },
    e0 = {
      HIDE: `hide${e3}`,
      HIDDEN: `hidden${e3}`,
      SHOW: `show${e3}`,
      SHOWN: `shown${e3}`,
      INSERTED: `inserted${e3}`,
      CLICK: `click${e3}`,
      FOCUSIN: `focusin${e3}`,
      FOCUSOUT: `focusout${e3}`,
      MOUSEENTER: `mouseenter${e3}`,
      MOUSELEAVE: `mouseleave${e3}`,
    };
  class e4 extends eQ {
    static get Default() {
      return e1;
    }
    static get NAME() {
      return "popover";
    }
    static get Event() {
      return e0;
    }
    static get DefaultType() {
      return e2;
    }
    static jQueryInterface(e) {}
  }
  g(e4);
  let e6 = "load.bs.scrollspy.data-api";
  class eG extends T {}
  k.on(window, e6, () => {
    j.find('[data-bs-spy="scroll"]').forEach((e) => new eG(e));
  }),
    g(eG);
  let eJ = "click.bs.tab.data-api";
  class eZ extends T {
    static get NAME() {
      return "tab";
    }
  }
  k.on(
    document,
    eJ,
    '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
    function (e) {}
  ),
    g(eZ);
  class e5 extends T {
    static get NAME() {
      return "toast";
    }
  }
  return (
    _(e5),
    g(e5),
    {
      Alert: C,
      Button: M,
      Carousel: el,
      Collapse: eu,
      Dropdown: e_,
      Modal: ej,
      Offcanvas: eK,
      Popover: e4,
      ScrollSpy: eG,
      Tab: eZ,
      Toast: e5,
      Tooltip: eQ,
    }
  );
});
